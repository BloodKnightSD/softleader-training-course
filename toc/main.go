package main

import (
	"os"
	"path/filepath"
	"strconv"
	"io/ioutil"
	"path"
	"sort"
	"github.com/softleader/captain-kube/tmpl"
	"fmt"
)

const (
	readme        = "README.md"
	readmeContent = `# Table Of Contents
> Auto-generated by *toc-${os}*
{{- $years := index . "years" }}
{{- $courses := index . "courses" }}
{{- range $_, $year := $years }}

## {{ $year -}}
{{ range $_, $season := index $courses $year }}

### [{{ $season.Season }}](../{{ $year }}/{{ $season.Season }}) 
{{ range $_, $course := $season.Courses }}
- [{{ $course.Course }}](../{{ $course.Year }}/{{ $course.Season }}/{{ $course.Course }}) 
{{- end }}
{{- end }}
{{- end }}
`
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	root := filepath.Dir(wd)

	var courses []Course

	// collect course dir
	walkDir(root, 0, 2, func(path string) {
		season := filepath.Dir(path)
		year := filepath.Dir(season)
		y, e := strconv.Atoi(filepath.Base(year))
		if e == nil {
			c := Course{
				Year:   y,
				Season: filepath.Base(season),
				Course: filepath.Base(path),
			}
			courses = append(courses, c)
		}
	})

	var years []int
	groupByYear := make(map[int]Seasons)
	for _, c := range courses {
		if seasons, found := groupByYear[c.Year]; found {
			seasons.add(c)
			groupByYear[c.Year] = seasons
		} else {
			seasons = Seasons{}
			seasons.add(c)
			groupByYear[c.Year] = seasons
			years = append(years, c.Year)
		}
	}

	// Reversing years
	sort.Ints(years)
	for i := len(years)/2 - 1; i >= 0; i-- {
		opp := len(years) - 1 - i
		years[i], years[opp] = years[opp], years[i]
	}

	data := make(map[string]interface{})
	data["years"] = years
	data["courses"] = groupByYear

	md := filepath.Join(wd, readme)
	err = tmpl.CompileTo(readmeContent, data, md)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Successfully genereated %s\n", md)
}

// 在第 depth 層的時候依序針對當下的 dir 執行 walkFn
func walkDir(dirpath string, currentDepth int, depth int, walkFn func(path string)) {
	if currentDepth > depth {
		return
	}
	files, err := ioutil.ReadDir(dirpath)
	if err != nil {
		return
	}
	for _, file := range files {
		if file.IsDir() {
			p := path.Join(dirpath, file.Name())
			if currentDepth == depth {
				walkFn(p)
			}
			walkDir(p, currentDepth+1, depth, walkFn)
			continue
		} else {
			continue
		}
	}
}

type Seasons []Season

func (seasons *Seasons) add(c Course) {
	for i := 0; i < len(*seasons); i++ {
		if (*seasons)[i].Season == c.Season {
			(*seasons)[i].Courses = append((*seasons)[i].Courses, c)
			return
		}
	}
	*seasons = append(*seasons, Season{
		Season:  c.Season,
		Courses: []Course{c},
	})
}

type Season struct {
	Season  string
	Courses []Course
}

type Course struct {
	Year   int
	Season string
	Course string
}
