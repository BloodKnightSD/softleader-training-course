package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

const (
	header  = `## Courses`
	readme  = "README.md"
	content = `
> Auto-generated by *toc*
{{- $years := index . "years" }}
{{- $courses := index . "courses" }}
{{- range $_, $year := $years }}

## {{ $year -}}
{{ range $_, $season := index $courses $year }}

### [{{ $season.Season }}](../{{ $year }}/{{ $season.Season }}) 
{{ range $_, $course := $season.Courses }}
- [{{ $course.Course }}](../{{ $course.Year }}/{{ $course.Season }}/{{ $course.Course }}) 
{{- end }}
{{- end }}
{{- end }}
`
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		log.Panicln(err)
	}

	// 爬子目錄收集所有課程目錄
	var courses []Course
	walkDir(wd, 0, 2, func(path string) {
		season := filepath.Dir(path)
		year := filepath.Dir(season)
		y, e := strconv.Atoi(filepath.Base(year))
		if e == nil {
			c := Course{
				Year:   y,
				Season: filepath.Base(season),
				Course: filepath.Base(path),
			}
			courses = append(courses, c)
		}
	})

	// 將課程轉換成 template 容易使用的 struct
	var years []int
	groupByYear := make(map[int]Seasons)
	for _, c := range courses {
		if seasons, found := groupByYear[c.Year]; found {
			seasons.add(c)
			groupByYear[c.Year] = seasons
		} else {
			seasons = Seasons{}
			seasons.add(c)
			groupByYear[c.Year] = seasons
			years = append(years, c.Year)
		}
	}

	// Reversing years
	sort.Ints(years)
	for i := len(years)/2 - 1; i >= 0; i-- {
		opp := len(years) - 1 - i
		years[i], years[opp] = years[opp], years[i]
	}

	// 套用 template
	data := make(map[string]interface{})
	data["years"] = years
	data["courses"] = groupByYear
	var buf bytes.Buffer
	t := template.Must(template.New("").Parse(content))
	err = t.Execute(&buf, data)

	// 跟當前的 README.md 合併
	md := filepath.Join(wd, readme)
	input, err := ioutil.ReadFile(md)
	if err != nil {
		log.Panicf("Failed reading readme file: %s\n", err)
	}
	origin := strings.Split(string(input), header)[0]
	total := origin + header + buf.String()
	ioutil.WriteFile(readme, []byte(total), os.ModePerm)

	fmt.Printf("Successfully genereated %s\n", md)
}

// 在第 depth 層的時候依序針對當下的 dir 執行 walkFn
func walkDir(dirpath string, currentDepth int, depth int, walkFn func(path string)) {
	if currentDepth > depth {
		return
	}
	files, err := ioutil.ReadDir(dirpath)
	if err != nil {
		return
	}
	for _, file := range files {
		if file.IsDir() {
			p := path.Join(dirpath, file.Name())
			if currentDepth == depth {
				walkFn(p)
			}
			walkDir(p, currentDepth+1, depth, walkFn)
			continue
		} else {
			continue
		}
	}
}

type Seasons []Season

func (seasons *Seasons) add(c Course) {
	for i := 0; i < len(*seasons); i++ {
		if (*seasons)[i].Season == c.Season {
			(*seasons)[i].Courses = append((*seasons)[i].Courses, c)
			return
		}
	}
	*seasons = append(*seasons, Season{
		Season:  c.Season,
		Courses: []Course{c},
	})
}

type Season struct {
	Season  string
	Courses []Course
}

type Course struct {
	Year   int
	Season string
	Course string
}
